"use strict";(self.webpackChunkbeta_BNB_Docs=self.webpackChunkbeta_BNB_Docs||[]).push([[2264],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return p}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=l(n),p=i,f=h["".concat(c,".").concat(p)]||h[p]||u[p]||r;return n?a.createElement(f,o(o({ref:t},d),{},{components:n})):a.createElement(f,o({ref:t},d))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},70102:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return h}});var a=n(87462),i=n(63366),r=(n(67294),n(3905)),o=["components"],s={sidebar_label:"Native Asset Bridge"},c="Native Asset Bridge",l={unversionedId:"bas/architecture/native-asset-bridge",id:"bas/architecture/native-asset-bridge",isDocsHomePage:!1,title:"Native Asset Bridge",description:"BAS brings a native cross-chain bridge that is embedded to BAS as a system smart contract. Here we specify interfaces for the EVM version of BAS:",source:"@site/docs/bas/architecture/native-asset-bridge.md",sourceDirName:"bas/architecture",slug:"/bas/architecture/native-asset-bridge",permalink:"/docs/bas/architecture/native-asset-bridge",editUrl:"https://github.com/RumeelHussainbnb/beta_BSC_Docs/docs/bas/architecture/native-asset-bridge.md",tags:[],version:"current",frontMatter:{sidebar_label:"Native Asset Bridge"},sidebar:"bscSideBar",previous:{title:"Circulation Model and Native Asset Bridge",permalink:"/docs/bas/architecture/circulation-model-and-native-asset-bridge"},next:{title:"Blockchain and EVM Security",permalink:"/docs/bas/security/blockchain-and-evm-security"}},d=[{value:"BAS validator hub",id:"bas-validator-hub",children:[],level:2},{value:"Block header verification",id:"block-header-verification",children:[],level:2}],u={toc:d};function h(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"native-asset-bridge"},"Native Asset Bridge"),(0,r.kt)("p",null,"BAS brings a native cross-chain bridge that is embedded to BAS as a system smart contract. Here we specify interfaces for the EVM version of BAS:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"interface INativeAssetBridge {\n  function deposit() external payable;\n  function withdraw(bytes[] validatorSetSignatures, bytes transactionReceipt) external;\n}\n")),(0,r.kt)("p",null,"Native asset bridge supports next user flows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Deposit (BAS -> BSC). When a user calls a deposit function it locks his native tokens in the smart contract and emits events. To be able to mint peg tokens in the BSC chain, the user generates proof that contains information about transaction receipt (including emitted events) with Merkle Patricia trie proof. This proof should be uploaded into the BSC chain where a BASValidatorHub smart contract can verify this proof and validators signatures from the BAS chain."),(0,r.kt)("li",{parentName:"ul"},"Withdrawal (BSC -> BAS). Withdrawal of the funds is opposite to deposit flow. The difference here is that the user must burn his pegged tokens in the BSC chain to use this proof to withdraw tokens from native asset bridge smart contracts. Validators in the BAS network must verify the correctness of this operation and are responsible for preventing double-spend attacks.")),(0,r.kt)("p",null,"BAS developers might specify fees for inter-chain operations and cross-chain operations between BAS and BSC chains. Such policy should be specified in the BAS smart contract and fees or fines-related mechanisms shouldn\u2019t be presented in BSC smart contracts or block verification functions."),(0,r.kt)("h2",{id:"bas-validator-hub"},"BAS validator hub"),(0,r.kt)("p",null,"By default, BSC brings only native asset cross-chain functionality to the BAS applications. To reach this, each BAS application must be registered in the BSC smart contract. This smart contract assigns chain id to the BAS application and specifies BHVF (block header verification function). This function is used to verify the block header, but w/o state transitions. BHVF should be written in Solidity and be able to verify the block header, the correctness of the chain for N blocks, and check signatures. Since default BAS implementation is BSC-based then default chain implementation is supported by BAS validator hub, we define such function to allow other developers that don\u2019t want to rely on EVM or Parlia consensus engine to write their own verification function. Of course, developers might publish malicious functions or a function with a vulnerability that allows them to skip block verification and they should provide an audition of this code to be trusted by a community."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"interface IBlockHeaderVerificationFunction {\n    function verifyBlockHeader(bytes rawBlockHeader, address[] existingValidatorSet) external pure returns (address[] newValidatorSet);\n    \n    function verifyCrossChainPacket(bytes rawBlockHeader, bytes receiptsProof, bytes rawReceipt) external pure returns (\n        uint256 transferredAmount,\n        address recipientAddress\n    );\n}\ninterface BASValidatorHub {\n  function registerBAS(string projectName, address[] initialValidatorSet, IBlockHeaderVerificationFunction bhvf) external;\n}\n")),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"This interface is a draft and might change in the future."))),(0,r.kt)("p",null,"System contract address of BAS Validator Hub smart contract is: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0x0000000000000000000000000000000000007000\n")),(0,r.kt)("h2",{id:"block-header-verification"},"Block header verification"),(0,r.kt)("p",null,"BAS is not designed to have a BSC-compatible consensus or EVM execution environment, because BAS is a technology-agnostic solution. We provide only basic functionality for the BAS applications and help them to set up their work and be a part of the BSC ecosystem. We can\u2019t verify each operation on the chain, so we fully trust the developers of each BAS. However, we must be sure that validator transition is not compromised \u2014 that is a strict requirement for the cross-chain operations for the native asset. To reach this, we\u2019d like to introduce a block header verification function (BHVF) that must be specified by the BAS development team. BHVF is a function in the Solidity language that is able to verify block headers from BAS applications. This is a simplified version of the state verification function from Polkadot. BHVF is one of the required parameters to register BAS in the BSC\u2019s smart contract. Also, BHVF is responsible for verifying transaction receipt from blockchain that allows to prove the correctness of cross-chain transfer from BAS to BSC chain."),(0,r.kt)("p",null,"Block header verification is not a very complicated function, but we will have to verify block headers to be sure that the validator transition is well-done. Also using BLS/BN we don\u2019t have to pass all block headers into it, it\u2019s enough to publish only epoch blocks that contain new validator sets and signatures from all previous validators."),(0,r.kt)("p",null,"If we assume that block verification consumes ~50k gas (w/ state modification), then we have the next calculations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Per each block: 50k gas/block, then it is ~16k gas/sec."),(0,r.kt)("li",{parentName:"ul"},"Per epoch: 50k gas/epoch (epoch can be from 5 minutes up to 1 day), then it's between ~160 gas/sec (for 5 min epoch) and 0.57 gas/sec (for 1-day epoch).")),(0,r.kt)("p",null,"Of course, gas consumption depends on the epoch length and it's not required for BAS to have very short epochs. Epoch length of one day is recommended to be used for validator transition. It can be reduced based on application needs to 6-12 hours, but it doesn\u2019t change gas consumption a lot."))}h.isMDXComponent=!0}}]);